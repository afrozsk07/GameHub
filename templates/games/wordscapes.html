{% extends "base.html" %}

{% block title %}Wordscapes - GameHub{% endblock %}

{% block content %}
<div class="max-w-4xl mx-auto bg-white rounded-lg shadow-lg p-6">
    <!-- Header -->
    <div class="flex justify-between items-center mb-6">
        <button onclick="window.location.href='/'" class="w-12 h-12 rounded-full bg-gray-700 flex items-center justify-center text-white hover:bg-gray-800">
            <i class="fas fa-arrow-left"></i>
        </button>
        <h1 class="text-3xl font-bold text-center text-indigo-600">Level <span id="level">1</span></h1>
        <div class="w-12 h-12"></div>
    </div>

    <!-- Game Mode Selection -->
    <div id="mode-selection" class="mb-8">
        <h2 class="text-xl font-semibold mb-4 text-center">Select Difficulty</h2>
        <div class="grid grid-cols-3 gap-4">
            <button class="difficulty-btn px-6 py-4 rounded-lg bg-green-500 text-white hover:bg-green-600" data-difficulty="easy">
                <i class="fas fa-star text-2xl mb-2"></i>
                <span class="block">Easy</span>
                <span class="text-sm">(4-5 letters)</span>
            </button>
            <button class="difficulty-btn px-6 py-4 rounded-lg bg-yellow-500 text-white hover:bg-yellow-600" data-difficulty="medium">
                <i class="fas fa-star-half-alt text-2xl mb-2"></i>
                <span class="block">Medium</span>
                <span class="text-sm">(6-7 letters)</span>
            </button>
            <button class="difficulty-btn px-6 py-4 rounded-lg bg-red-500 text-white hover:bg-red-600" data-difficulty="hard">
                <i class="fas fa-stars text-2xl mb-2"></i>
                <span class="block">Hard</span>
                <span class="text-sm">(8+ letters)</span>
            </button>
        </div>
    </div>

    <!-- Game Area -->
    <div id="game-area" class="hidden">
        <!-- Score Display -->
        <div class="flex justify-between mb-4">
            <div class="flex items-center">
                <div class="w-8 h-8 rounded-full bg-yellow-400 flex items-center justify-center mr-2">
                    <i class="fas fa-coins text-yellow-700"></i>
                </div>
                <span id="score" class="text-xl font-bold">0</span>
            </div>
        </div>

        <!-- Main Game Grid -->
        <div class="flex flex-col md:flex-row gap-6">
            <!-- Left Side - Word Display -->
            <div class="flex-1 bg-gradient-to-br from-indigo-50 to-purple-50 rounded-lg p-6 flex items-center justify-center">
                <div id="puzzle-container" class="w-full max-w-lg">
                    <!-- Word Cloud Container -->
                    <div id="word-cloud" class="relative w-full aspect-square bg-white rounded-xl shadow-lg p-8 flex flex-wrap justify-center items-center">
                        <!-- Progress Circle -->
                        <svg class="absolute inset-0 w-full h-full" viewBox="0 0 100 100" style="transform: rotate(-90deg)">
                            <circle id="progress-bg"
                                cx="50" cy="50" 
                                r="48"
                                fill="none"
                                stroke="#f0f0f0"
                                stroke-width="2"
                            />
                            <circle id="progress-circle"
                                cx="50" cy="50" 
                                r="48"
                                fill="none"
                                stroke="#4f46e5"
                                stroke-width="2"
                                pathLength="100"
                                stroke-dasharray="100"
                                stroke-dashoffset="100"
                                stroke-linecap="round"
                                class="transition-all duration-1000"
                            />
                        </svg>
                        <!-- Word slots will be added dynamically -->
                    </div>
                    <!-- Found Words Display -->
                    <div id="found-words" class="mt-6 grid grid-cols-2 gap-2 text-sm">
                        <!-- Found words will be displayed here -->
                    </div>
                </div>
            </div>

            <!-- Right Side - Letter Wheel and Controls -->
            <div class="flex-1 flex flex-col items-center justify-between">
                <div class="relative w-64">
                    <div id="current-word" class="text-center text-3xl font-bold text-indigo-600 bg-white shadow-md rounded-full px-6 py-2 mb-6 min-h-[48px] flex items-center justify-center"></div>
                    <canvas id="letter-wheel" class="w-full h-64" width="256" height="256"></canvas>
                </div>

                <!-- Controls -->
                <div class="flex flex-col gap-3 w-full max-w-xs mt-4">
                    <button id="shuffle-btn" class="w-full px-6 py-3 bg-yellow-500 text-white rounded-lg hover:bg-yellow-600 flex items-center justify-center">
                        <i class="fas fa-random mr-2"></i>Shuffle
                    </button>
                    <button id="hint-btn" class="w-full px-6 py-3 bg-blue-500 text-white rounded-lg hover:bg-blue-600 flex items-center justify-center">
                        <i class="fas fa-lightbulb mr-2"></i>Hint (20<i class="fas fa-coins text-yellow-300 ml-1"></i>)
                    </button>
                    <button id="clear-btn" class="w-full px-6 py-3 bg-red-500 text-white rounded-lg hover:bg-red-600 flex items-center justify-center">
                        <i class="fas fa-times mr-2"></i>Clear
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Level Complete Modal -->
    <div id="level-complete-modal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
        <div class="bg-white p-8 rounded-lg max-w-md w-full mx-4">
            <h2 class="text-2xl font-bold text-center mb-4">Level Complete!</h2>
            <div class="space-y-2 mb-6">
                <p class="text-center">Words Found: <span id="final-words-found" class="font-bold"></span></p>
                <p class="text-center">Score: <span id="final-score" class="font-bold"></span></p>
            </div>
            <div class="flex justify-center space-x-4">
                <button id="next-level-btn" class="bg-green-600 text-white px-6 py-2 rounded-lg hover:bg-green-700">
                    Next Level
                </button>
                <button id="exit-btn" class="bg-gray-600 text-white px-6 py-2 rounded-lg hover:bg-gray-700">
                    Exit
                </button>
            </div>
        </div>
    </div>
</div>

<script>
document.addEventListener('DOMContentLoaded', () => {
    const canvas = document.getElementById('letter-wheel');
    const ctx = canvas.getContext('2d');
    const crosswordGrid = document.getElementById('crossword-grid');
    let letters = [];
    let currentWord = '';
    let foundWords = new Set();
    let targetWords = new Set();
    let gridCells = [];
    let score = 0;
    let hintsLeft = 3;
    let currentLevel = 1;
    let selectedLetters = [];
    let isDrawing = false;
    let currentDifficulty = '';
    
    // Grid boundary tracking variables
    let minRow = 0, maxRow = 0, minCol = 0, maxCol = 0;
    
    // Initialize the game
    function initGame(difficulty) {
        currentDifficulty = difficulty;
        document.getElementById('mode-selection').classList.add('hidden');
        document.getElementById('game-area').classList.remove('hidden');
        currentLevel = 1;
        score = 0;
        loadLevel(difficulty, currentLevel);
    }

    // Create crossword grid cell
    function createGridCell(isActive = false) {
        const cell = document.createElement('div');
        cell.className = `relative ${isActive ? 'block' : 'invisible'}`;  // Changed from hidden to invisible to maintain grid structure
        cell.style.paddingBottom = '100%'; // Makes cell square
        
        const inner = document.createElement('div');
        inner.className = 'absolute inset-0 flex items-center justify-center text-2xl font-bold text-gray-800 bg-white border border-gray-300 m-0.5 rounded-sm transition-colors duration-200';
        
        cell.appendChild(inner);
        return cell;
    }

    // Update crossword grid
    function updateCrosswordGrid(words) {
        crosswordGrid.innerHTML = '';
        const gridSize = 15;
        const grid = Array(gridSize).fill().map(() => Array(gridSize).fill(null));
        const usedCells = Array(gridSize).fill().map(() => Array(gridSize).fill(false));
        const wordCoordinates = new Map(); // Track coordinates for each word
        gridCells = [];

        // Sort words by length and uniqueness of letters
        const sortedWords = Array.from(words).sort((a, b) => {
            const lenDiff = b.length - a.length;
            if (lenDiff !== 0) return lenDiff;
            return new Set(b.split('')).size - new Set(a.split('')).size;
        });

        // Initialize grid boundaries
        minRow = gridSize;
        maxRow = 0;
        minCol = gridSize;
        maxCol = 0;

        // Place words in a more structured way
        let currentRow = Math.floor(gridSize / 2);
        let isHorizontal = true;

        for (let i = 0; i < sortedWords.length; i++) {
            const word = sortedWords[i];
            let placed = false;

            if (isHorizontal) {
                // Try to place horizontally
                const col = Math.floor((gridSize - word.length) / 2);
                if (canPlaceWord(grid, usedCells, word, currentRow, col, true)) {
                    placeWord(grid, usedCells, word, currentRow, col, true);
                    updateBoundaries(currentRow, col, currentRow, col + word.length - 1);
                    // Store word coordinates
                    const coords = [];
                    for (let j = 0; j < word.length; j++) {
                        coords.push({row: currentRow, col: col + j, word: word});
                    }
                    wordCoordinates.set(word, coords);
                    placed = true;
                }
            } else {
                // Try to place vertically
                const row = currentRow - Math.floor(word.length / 2);
                const col = Math.floor(gridSize / 2);
                if (canPlaceWord(grid, usedCells, word, row, col, false)) {
                    placeWord(grid, usedCells, word, row, col, false);
                    updateBoundaries(row, col, row + word.length - 1, col);
                    // Store word coordinates
                    const coords = [];
                    for (let j = 0; j < word.length; j++) {
                        coords.push({row: row + j, col: col, word: word});
                    }
                    wordCoordinates.set(word, coords);
                    placed = true;
                }
            }

            if (placed) {
                currentRow += (isHorizontal ? 2 : 0);
                isHorizontal = !isHorizontal;
            }
        }

        // Create visual grid
        const padding = 1;
        const actualRows = maxRow - minRow + 1 + (padding * 2);
        const actualCols = maxCol - minCol + 1 + (padding * 2);
        const finalSize = Math.max(actualRows, actualCols);

        // Update grid container styles
        crosswordGrid.style.gridTemplateColumns = `repeat(${finalSize}, minmax(2rem, 1fr))`;
        crosswordGrid.style.gridTemplateRows = `repeat(${finalSize}, minmax(2rem, 1fr))`;
        crosswordGrid.style.gap = '2px';
        crosswordGrid.style.backgroundColor = '#e5e7eb';
        crosswordGrid.style.padding = '0.5rem';
        crosswordGrid.style.width = '100%';
        crosswordGrid.style.maxWidth = '100%';
        crosswordGrid.style.aspectRatio = '1';

        // Center the puzzle in the grid
        const rowOffset = Math.floor((finalSize - (maxRow - minRow + 1)) / 2);
        const colOffset = Math.floor((finalSize - (maxCol - minCol + 1)) / 2);

        // Create and place cells
        for (let i = 0; i < finalSize; i++) {
            for (let j = 0; j < finalSize; j++) {
                const actualRow = i - rowOffset + minRow;
                const actualCol = j - colOffset + minCol;
                
                const isActive = actualRow >= minRow && actualRow <= maxRow &&
                               actualCol >= minCol && actualCol <= maxCol &&
                               grid[actualRow] && grid[actualRow][actualCol] !== null;
                
                const cell = createGridCell(isActive);

                if (isActive) {
                    const inner = cell.querySelector('div');
                    inner.dataset.letter = grid[actualRow][actualCol];
                    inner.dataset.row = actualRow.toString();
                    inner.dataset.col = actualCol.toString();
                    
                    // Store word coordinates for this cell
                    const cellWordCoords = [];
                    wordCoordinates.forEach((coords, word) => {
                        if (coords.some(coord => coord.row === actualRow && coord.col === actualCol)) {
                            cellWordCoords.push({word: word});
                        }
                    });
                    inner.dataset.wordCoords = JSON.stringify(cellWordCoords);

                    // Add number labels for word starts
                    if (isWordStart(grid, actualRow, actualCol)) {
                        const label = document.createElement('div');
                        label.className = 'absolute top-0 left-0 text-xs font-semibold text-gray-600 p-1';
                        label.textContent = getWordNumber(grid, actualRow, actualCol);
                        inner.appendChild(label);
                    }
                }

                crosswordGrid.appendChild(cell);
                gridCells.push(cell);
            }
        }
    }

    // Helper function to place the first word
    function placeFirstWord(grid, usedCells, word, row, col) {
        if (row < 0 || col < 0 || row >= grid.length || col + word.length > grid.length) {
            return false;
        }
        
        const letters = word.toUpperCase().split('');
        letters.forEach((letter, index) => {
            grid[row][col + index] = letter;
            usedCells[row][col + index] = true;
        });
        
        return true;
    }

    // Helper function to check if a cell is the start of a word
    function isWordStart(grid, row, col) {
        const gridSize = grid.length;
        const hasLetter = grid[row][col] !== null;
        
        // Check if it's the start of a horizontal word
        const isHorizontalStart = hasLetter &&
            (col === 0 || grid[row][col - 1] === null) &&
            (col + 1 < gridSize && grid[row][col + 1] !== null);
        
        // Check if it's the start of a vertical word
        const isVerticalStart = hasLetter &&
            (row === 0 || grid[row - 1][col] === null) &&
            (row + 1 < gridSize && grid[row + 1][col] !== null);
        
        return isHorizontalStart || isVerticalStart;
    }

    // Helper function to get the word number for a cell
    function getWordNumber(grid, row, col) {
        let number = 1;
        for (let i = 0; i < grid.length; i++) {
            for (let j = 0; j < grid.length; j++) {
                if (i === row && j === col) {
                    return number;
                }
                if (isWordStart(grid, i, j)) {
                    number++;
                }
            }
        }
        return number;
    }

    // Helper function to find best placement for a word with improved scoring
    function findBestPlacement(grid, usedCells, word, placedWords) {
        const gridSize = grid.length;
        let bestPlacement = null;
        let bestScore = -1;

        // Try every possible position and orientation
        for (let row = 0; row < gridSize; row++) {
            for (let col = 0; col < gridSize; col++) {
                // Try horizontal placement
                if (canPlaceWord(grid, usedCells, word, row, col, false)) {
                    const score = calculatePlacementScore(grid, word, row, col, false, placedWords);
                    if (score > bestScore) {
                        bestScore = score;
                        bestPlacement = { row, col, isVertical: false, score };
                    }
                }
                
                // Try vertical placement
                if (canPlaceWord(grid, usedCells, word, row, col, true)) {
                    const score = calculatePlacementScore(grid, word, row, col, true, placedWords);
                    if (score > bestScore) {
                        bestScore = score;
                        bestPlacement = { row, col, isVertical: true, score };
                    }
                }
            }
        }

        return bestPlacement;
    }

    // Helper function to calculate placement score
    function calculatePlacementScore(grid, word, row, col, isVertical, placedWords) {
        let score = 0;
        const letters = word.toUpperCase().split('');
        
        // Base score from intersections
        score += countIntersections(grid, word, row, col, isVertical) * 10;
        
        // Bonus for creating more intersection opportunities
        letters.forEach((letter, i) => {
            const r = row + (isVertical ? i : 0);
            const c = col + (isVertical ? 0 : i);
            
            // Check adjacent cells for potential future intersections
            if (isVertical) {
                if (c > 0 && grid[r][c-1] === null) score += 1;
                if (c < grid.length-1 && grid[r][c+1] === null) score += 1;
            } else {
                if (r > 0 && grid[r-1][c] === null) score += 1;
                if (r < grid.length-1 && grid[r+1][c] === null) score += 1;
            }
        });
        
        // Penalty for increasing grid size
        const endRow = row + (isVertical ? word.length - 1 : 0);
        const endCol = col + (isVertical ? 0 : word.length - 1);
        const maxDimension = Math.max(endRow - row, endCol - col);
        score -= maxDimension;
        
        return score;
    }

    // Helper function to place a word with validation
    function placeWord(grid, usedCells, word, row, col, isVertical) {
        if (!canPlaceWord(grid, usedCells, word, row, col, isVertical)) {
            return false;
        }

        const letters = word.toUpperCase().split('');
        letters.forEach((letter, index) => {
            const r = row + (isVertical ? index : 0);
            const c = col + (isVertical ? 0 : index);
            grid[r][c] = letter;
            usedCells[r][c] = true;
        });

        return true;
    }

    // Helper function to update grid boundaries
    function updateBoundaries(startRow, startCol, endRow, endCol) {
        minRow = Math.min(minRow, startRow);
        maxRow = Math.max(maxRow, endRow);
        minCol = Math.min(minCol, startCol);
        maxCol = Math.max(maxCol, endCol);
    }

    // Helper function to check if a word can be placed
    function canPlaceWord(grid, usedCells, word, row, col, isVertical) {
        const gridSize = grid.length;
        const wordLength = word.length;

        // Check if word fits within grid bounds
        if (isVertical) {
            if (row < 0 || row + wordLength > gridSize) return false;
            if (col < 0 || col >= gridSize) return false;
        } else {
            if (row < 0 || row >= gridSize) return false;
            if (col < 0 || col + wordLength > gridSize) return false;
        }

        // Check each position where the word would be placed
        for (let i = 0; i < wordLength; i++) {
            const r = row + (isVertical ? i : 0);
            const c = col + (isVertical ? 0 : i);
            const currentLetter = word[i].toUpperCase();

            // Check if cell is already used by a different letter
            if (grid[r][c] !== null && grid[r][c] !== currentLetter) {
                return false;
            }

            // Check adjacent cells (no touching words unless intersecting)
            if (grid[r][c] === null) {
                // Check cells above and below
                if (r > 0 && !isVertical && grid[r-1][c] !== null) return false;
                if (r < gridSize-1 && !isVertical && grid[r+1][c] !== null) return false;
                // Check cells to left and right
                if (c > 0 && isVertical && grid[r][c-1] !== null) return false;
                if (c < gridSize-1 && isVertical && grid[r][c+1] !== null) return false;
            }
        }

        return true;
    }

    // Helper function to count intersections for a potential placement
    function countIntersections(grid, word, row, col, isVertical) {
        let intersections = 0;
        const letters = word.toUpperCase().split('');

        letters.forEach((letter, i) => {
            const r = row + (isVertical ? i : 0);
            const c = col + (isVertical ? 0 : i);
            if (grid[r][c] === letter) {
                intersections++;
            }
        });

        return intersections;
    }

    // Create word slot element with enhanced styling
    function createWordSlot(word, index, totalWords) {
        const slot = document.createElement('div');
        slot.className = 'flex gap-1.5 p-3 rounded-lg transition-all duration-500 transform hover:scale-105 relative z-0';
        slot.dataset.wordIndex = index;
        
        // Calculate position in a circular pattern
        const angle = (index * 2 * Math.PI) / totalWords;
        const radius = 42; // Percentage of container size
        const x = Math.cos(angle) * radius;
        const y = Math.sin(angle) * radius;
        
        // Create letter boxes
        for (let i = 0; i < word.length; i++) {
            const letterBox = document.createElement('div');
            letterBox.className = 'w-9 h-9 border-2 border-indigo-200 rounded-lg flex items-center justify-center font-bold text-lg bg-white shadow-sm transition-all duration-300';
            slot.appendChild(letterBox);
        }

        // Add length indicator
        const lengthIndicator = document.createElement('div');
        lengthIndicator.className = 'absolute -top-2 -right-2 bg-indigo-500 text-white text-xs rounded-full w-5 h-5 flex items-center justify-center shadow-md';
        lengthIndicator.textContent = word.length;
        slot.appendChild(lengthIndicator);

        // Position the slot
        slot.style.transform = `translate(${x}%, ${y}%) rotate(${angle}rad)`;
        
        return slot;
    }

    // Update word display with enhanced animations
    function updateWordDisplay(words) {
        const wordCloud = document.getElementById('word-cloud');
        const progressCircle = document.getElementById('progress-circle');
        const progressBg = document.getElementById('progress-bg');
        
        // Clear existing content but keep SVG
        Array.from(wordCloud.children).forEach(child => {
            if (child.tagName !== 'svg') {
                child.remove();
            }
        });
        
        // Update progress circle
        const progress = (foundWords.size / words.size) * 100;
        progressCircle.style.strokeDashoffset = 100 - progress;
        progressCircle.style.stroke = `hsl(${progress * 2.4}, 70%, 60%)`;
        
        // Create slots for each word with staggered animation
        Array.from(words).forEach((word, index) => {
            const slot = createWordSlot(word, index, words.size);
            
            if (foundWords.has(word)) {
                const letters = word.split('');
                slot.querySelectorAll('div').forEach((box, i) => {
                    if (box.classList.contains('absolute')) return; // Skip length indicator
                    box.textContent = letters[i].toUpperCase();
                    box.className = 'w-9 h-9 border-2 border-green-400 rounded-lg flex items-center justify-center font-bold text-lg bg-green-50 text-green-700 shadow-md transition-all duration-300';
                });
                slot.classList.add('found');
            }
            
            // Add staggered entrance animation
            slot.style.opacity = '0';
            slot.style.scale = '0.8';
            wordCloud.appendChild(slot);
            
            setTimeout(() => {
                slot.style.opacity = '1';
                slot.style.scale = '1';
            }, index * 50);
        });
    }

    // Update UI elements with enhanced animations
    function updateUI() {
        // Update score with animation
        const scoreElement = document.getElementById('score');
        const currentScore = parseInt(scoreElement.textContent);
        if (currentScore < score) {
            animateNumber(scoreElement, currentScore, score, 500);
        } else {
            scoreElement.textContent = score;
        }

        document.getElementById('level').textContent = currentLevel;
        
        // Update current word with fade effect
        const currentWordElement = document.getElementById('current-word');
        const newWord = selectedLetters.map(i => letters[i].letter).join('').toUpperCase();
        if (currentWordElement.textContent !== newWord) {
            currentWordElement.style.opacity = '0';
            setTimeout(() => {
                currentWordElement.textContent = newWord;
                currentWordElement.style.opacity = '1';
            }, 150);
        }

        // Update found words with slide-in effect
        const foundWordsContainer = document.getElementById('found-words');
        foundWordsContainer.innerHTML = '';
        Array.from(foundWords).forEach((word, index) => {
            const wordEl = document.createElement('div');
            wordEl.className = 'px-3 py-2 bg-green-100 text-green-800 rounded text-center font-medium transform translate-x-full opacity-0 transition-all duration-300';
            wordEl.textContent = word.toUpperCase();
            foundWordsContainer.appendChild(wordEl);
            
            setTimeout(() => {
                wordEl.style.transform = 'translateX(0)';
                wordEl.style.opacity = '1';
            }, index * 100);
        });

        // Update word slots
        updateWordDisplay(targetWords);

        // Check if level is complete
        checkLevelComplete();
    }

    // Animate number changes
    function animateNumber(element, start, end, duration) {
        const range = end - start;
        const startTime = performance.now();
        
        function update() {
            const currentTime = performance.now();
            const elapsed = currentTime - startTime;
            const progress = Math.min(elapsed / duration, 1);
            
            const current = Math.round(start + (range * progress));
            element.textContent = current;
            
            if (progress < 1) {
                requestAnimationFrame(update);
            }
        }
        
        requestAnimationFrame(update);
    }

    // Load level data
    async function loadLevel(difficulty, level) {
        try {
            const response = await fetch(`/api/wordscapes/level/${difficulty}/${level}`);
            if (!response.ok) {
                if (response.status === 401) {
                    window.location.href = '/auth/login?next=' + encodeURIComponent(window.location.pathname);
                    return;
                }
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            const data = await response.json();
            if (data.error) {
                throw new Error(data.error);
            }
            letters = Array.from(data.letters).map((letter, index) => ({
                letter,
                x: 0,
                y: 0,
                selected: false
            }));
            targetWords = new Set(data.words);
            foundWords.clear();
            selectedLetters = [];
            updateUI();
            updateWordDisplay(targetWords);
            resizeCanvas();
        } catch (error) {
            console.error('Failed to load level:', error);
            alert('Failed to load level: ' + error.message);
        }
    }

    // Draw the letter wheel
    function drawLetterWheel() {
        const width = canvas.width;
        const height = canvas.height;
        const centerX = width / 2;
        const centerY = height / 2;
        const radius = Math.min(width, height) / 3;

        // Clear canvas
        ctx.clearRect(0, 0, width, height);

        // Draw connecting lines for selected letters
        if (selectedLetters.length > 1) {
            ctx.beginPath();
            ctx.strokeStyle = '#4338CA';
            ctx.lineWidth = 6; // Increased line width
            ctx.lineCap = 'round'; // Round line endings
            selectedLetters.forEach((index, i) => {
                const letter = letters[index];
                if (i === 0) {
                    ctx.moveTo(letter.x, letter.y);
                } else {
                    ctx.lineTo(letter.x, letter.y);
                }
            });
            ctx.stroke();
        }

        // Draw letter circles
        letters.forEach((letter, i) => {
            const angle = (i * 2 * Math.PI) / letters.length - Math.PI / 2;
            const x = centerX + radius * Math.cos(angle);
            const y = centerY + radius * Math.sin(angle);
            
            // Update letter positions
            letter.x = x;
            letter.y = y;
            letter.selected = selectedLetters.includes(i);

            // Draw circle shadow
            ctx.beginPath();
            ctx.arc(x, y + 2, 32, 0, 2 * Math.PI);
            ctx.fillStyle = 'rgba(0,0,0,0.1)';
            ctx.fill();

            // Draw circle
            ctx.beginPath();
            ctx.arc(x, y, 32, 0, 2 * Math.PI);
            ctx.fillStyle = letter.selected ? '#4338CA' : '#4F46E5';
            ctx.fill();

            // Draw letter
            ctx.fillStyle = 'white';
            ctx.font = 'bold 24px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(letter.letter.toUpperCase(), x, y);
        });
    }

    // Check if a point is inside a letter circle
    function getLetterAtPoint(x, y) {
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        const canvasX = (x - rect.left) * scaleX;
        const canvasY = (y - rect.top) * scaleY;

        return letters.findIndex(letter => {
            const dx = canvasX - letter.x;
            const dy = canvasY - letter.y;
            return Math.sqrt(dx * dx + dy * dy) <= 30;
        });
    }

    function showLevelComplete() {
        document.getElementById('level-complete-modal').classList.remove('hidden');
        document.getElementById('final-words-found').textContent = `${foundWords.size}/${targetWords.size}`;
        document.getElementById('final-score').textContent = score;
    }

    // Event Listeners
    document.querySelectorAll('.difficulty-btn').forEach(btn => {
        btn.addEventListener('click', () => {
            const difficulty = btn.dataset.difficulty;
            initGame(difficulty);
        });
    });

    document.getElementById('shuffle-btn').addEventListener('click', () => {
        const lettersCopy = [...letters];
        for (let i = lettersCopy.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [lettersCopy[i], lettersCopy[j]] = [lettersCopy[j], lettersCopy[i]];
        }
        letters = lettersCopy;
        selectedLetters = [];
        updateUI();
        drawLetterWheel();
    });

    document.getElementById('clear-btn').addEventListener('click', () => {
        selectedLetters = [];
        updateUI();
        drawLetterWheel();
    });

    document.getElementById('hint-btn').addEventListener('click', () => {
        if (score >= 20) {
            score -= 20;
            document.getElementById('score').textContent = score;
            const unsolvedWords = Array.from(targetWords).filter(word => !foundWords.has(word));
            if (unsolvedWords.length > 0) {
                const randomWord = unsolvedWords[Math.floor(Math.random() * unsolvedWords.length)];
                alert(`Hint: One of the words has ${randomWord.length} letters and starts with "${randomWord[0].toUpperCase()}"`);
            }
        } else {
            alert('Not enough coins for a hint!');
        }
    });

    document.getElementById('next-level-btn').addEventListener('click', () => {
        currentLevel++;
        loadLevel(currentDifficulty, currentLevel);
        document.getElementById('level-complete-modal').classList.add('hidden');
    });

    document.getElementById('exit-btn').addEventListener('click', () => {
        // Reset game state
        score = 0;
        hintsLeft = 3;
        foundWords.clear();
        selectedLetters = [];
        currentLevel = 1;
        
        // Hide game area and modal
        document.getElementById('game-area').classList.add('hidden');
        document.getElementById('level-complete-modal').classList.add('hidden');
        
        // Show mode selection
        document.getElementById('mode-selection').classList.remove('hidden');
        
        // Reset score display
        document.getElementById('score').textContent = '0';
    });

    // Canvas interaction
    canvas.addEventListener('mousedown', (e) => {
        isDrawing = true;
        selectedLetters = [];
        handlePointerEvent(e);
        drawLetterWheel();
    });

    canvas.addEventListener('mousemove', (e) => {
        if (!isDrawing) return;
        handlePointerEvent(e);
        drawLetterWheel();
    });

    canvas.addEventListener('mouseup', () => {
        isDrawing = false;
        const word = selectedLetters.map(i => letters[i].letter).join('').toLowerCase();
        if (targetWords.has(word) && !foundWords.has(word)) {
            foundWords.add(word);
            score += word.length * 10;
            updateUI();
        }
        selectedLetters = [];
        drawLetterWheel();
    });

    canvas.addEventListener('mouseleave', () => {
        isDrawing = false;
        selectedLetters = [];
        drawLetterWheel();
    });

    // Touch events for mobile
    canvas.addEventListener('touchstart', (e) => {
        e.preventDefault();
        isDrawing = true;
        selectedLetters = [];
        handlePointerEvent(e.touches[0]);
        drawLetterWheel();
    });

    canvas.addEventListener('touchmove', (e) => {
        e.preventDefault();
        if (!isDrawing) return;
        handlePointerEvent(e.touches[0]);
        drawLetterWheel();
    });

    canvas.addEventListener('touchend', (e) => {
        e.preventDefault();
        isDrawing = false;
        const word = selectedLetters.map(i => letters[i].letter).join('').toLowerCase();
        if (targetWords.has(word) && !foundWords.has(word)) {
            foundWords.add(word);
            score += word.length * 10;
            updateUI();
        }
        selectedLetters = [];
        drawLetterWheel();
    });

    // Handle pointer events
    function handlePointerEvent(e) {
        const letterIndex = getLetterAtPoint(e.clientX, e.clientY);
        if (letterIndex !== -1 && !selectedLetters.includes(letterIndex)) {
            selectedLetters.push(letterIndex);
            updateUI();
        }
    }

    // Initialize canvas size
    function resizeCanvas() {
        const container = canvas.parentElement;
        canvas.width = container.clientWidth;
        canvas.height = container.clientHeight;
        drawLetterWheel();
    }

    window.addEventListener('resize', resizeCanvas);

    function checkLevelComplete() {
        if (foundWords.size === targetWords.size) {
            // Submit score for the level
            submitScore('wordscapes', score);

            // Show level complete modal and update its fields
            showLevelComplete();
        }
    }

    // Function to submit score to backend
    async function submitScore(gameType, score) {
        try {
            const response = await fetch('/api/games/submit-score', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ game_type: gameType, score: score })
            });
            const data = await response.json();
            if (data.highScore) {
                console.log('New high score!');
            }
        } catch (error) {
            console.error('Error submitting score:', error);
        }
    }
});
</script>
{% endblock %} 